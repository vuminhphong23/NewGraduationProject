/**
 * Chat WebSocket Manager - T∆∞∆°ng t·ª± nh∆∞ notifications.js
 */
(() => {
    let chatWebSocket = null;
    let isConnected = false;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    let reconnectTimeout = null;
    
    // Kh·ªüi t·∫°o WebSocket connection
    async function initializeChatWebSocket() {
        if (chatWebSocket && chatWebSocket.readyState === WebSocket.OPEN) {
            return;
        }
        
        try {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            
            // Ki·ªÉm tra cache tr∆∞·ªõc
            let userId = null;
            if (window.currentUser && window.currentUser.id) {
                userId = window.currentUser.id;
            } else {
                userId = await getCurrentUserId();
            }
            
            if (!userId) {
                fallbackToPolling();
                return;
            }
            
            const wsUrl = `${protocol}//${window.location.host}/ws/chat?userId=${userId}`;
            
            chatWebSocket = new WebSocket(wsUrl);
            
            chatWebSocket.onopen = function(event) {
                isConnected = true;
                reconnectAttempts = 0;
            };
            
            chatWebSocket.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleChatWebSocketMessage(data);
                } catch (error) {
                    // Error parsing message
                }
            };
            
            chatWebSocket.onclose = function(event) {
                isConnected = false;
                chatWebSocket = null;
                
                // T·ª± ƒë·ªông reconnect n·∫øu ch∆∞a ƒë·∫°t max attempts
                if (reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000); // Exponential backoff
                    
                    reconnectTimeout = setTimeout(async () => {
                        await initializeChatWebSocket();
                    }, delay);
                } else {
                    fallbackToPolling();
                }
            };
            
            chatWebSocket.onerror = function(error) {
                // WebSocket error
            };
            
        } catch (error) {
            fallbackToPolling();
        }
    }
    
    // G·ª≠i message qua WebSocket
    function sendChatMessage(message) {
        if (chatWebSocket && chatWebSocket.readyState === WebSocket.OPEN) {
            try {
                chatWebSocket.send(JSON.stringify(message));
                return true;
            } catch (error) {
                return false;
            }
        } else {
            return false;
        }
    }
    
    // X·ª≠ l√Ω message t·ª´ WebSocket
    function handleChatWebSocketMessage(data) {
            
            switch (data.type) {
            case 'CONNECTION_ESTABLISHED':
                    break;
                
            case 'NEW_MESSAGE':
                handleNewMessage(data.message);
                    break;
                
            case 'MESSAGE_READ':
                handleMessageRead(data);
                    break;
                
                
            case 'USER_ONLINE':
                handleUserOnline(data);
                break;
                
            case 'USER_OFFLINE':
                handleUserOffline(data);
                break;
                
            case 'FILE_UPLOADED':
                handleFileUploaded(data);
                break;
                
            case 'FILES_UPLOADED':
                handleFilesUploaded(data);
                break;
                
            default:
                // Unknown message type
                break;
        }
    }
    
    // X·ª≠ l√Ω tin nh·∫Øn m·ªõi
    function handleNewMessage(messageData) {
        // N·∫øu ƒëang ·ªü room n√†y, th√™m message v√†o UI
        if (window.chatManager && window.chatManager.currentRoomId == messageData.roomId) {
            window.chatManager.addMessageToUI(messageData);
        }
        
        // C·∫≠p nh·∫≠t danh s√°ch rooms ƒë·ªÉ hi·ªÉn th·ªã tin nh·∫Øn m·ªõi nh·∫•t
        if (window.chatManager) {
            window.chatManager.updateRoomLastMessage(messageData.roomId, messageData);
        }
        
        // Hi·ªÉn th·ªã notification n·∫øu kh√¥ng ph·∫£i tin nh·∫Øn c·ªßa m√¨nh
        const currentUserId = getCurrentUserIdSync();
        if (currentUserId && messageData.senderId !== currentUserId) {
            showChatNotification(messageData);
        }
    }
    
    // X·ª≠ l√Ω message read status
    function handleMessageRead(data) {
        // C·∫≠p nh·∫≠t UI ƒë·ªÉ hi·ªÉn th·ªã "ƒë√£ xem" cho tin nh·∫Øn cu·ªëi c√πng
        if (window.chatManager && window.chatManager.currentRoomId === data.roomId) {
            window.chatManager.updateMessageReadStatus(data.roomId);
        }
    }
    
    
    // X·ª≠ l√Ω user online
    function handleUserOnline(data) {
        if (window.chatManager) {
            window.chatManager.updateUserOnlineStatus(data.userId, true);
        }
    }
    
    // X·ª≠ l√Ω user offline
    function handleUserOffline(data) {
        if (window.chatManager) {
            window.chatManager.updateUserOnlineStatus(data.userId, false);
        }
    }
    
    // X·ª≠ l√Ω file upload
    function handleFileUploaded(data) {
        // N·∫øu ƒëang ·ªü room n√†y, hi·ªÉn th·ªã file trong chat
        if (window.chatManager && window.chatManager.currentRoomId == data.roomId) {
            // T·∫°o message gi·∫£ ƒë·ªÉ hi·ªÉn th·ªã file
            const fileMessage = {
                id: 'temp_' + Date.now(),
                content: `üìé ${data.file.originalName}`, // Content text cho sidebar
                senderId: data.userId,
                senderName: 'B·∫°n',
                createdAt: new Date().toISOString(),
                isRead: true,
                attachments: [data.file] // S·ª≠ d·ª•ng attachments thay v√¨ file
            };
            
            window.chatManager.addMessageToUI(fileMessage);
        }
        
        // C·∫≠p nh·∫≠t files sidebar n·∫øu ƒëang m·ªü
        if (window.chatFilesManager && window.chatFilesManager.currentRoomId == data.roomId) {
            window.chatFilesManager.addFile(data.file);
        }
        
        // Hi·ªÉn th·ªã notification n·∫øu kh√¥ng ph·∫£i file c·ªßa m√¨nh
        const currentUserId = getCurrentUserIdSync();
        if (currentUserId && data.userId !== currentUserId) {
            showFileNotification(data.file, data.userId);
        }
    }
    
    // X·ª≠ l√Ω multiple files upload
    function handleFilesUploaded(data) {
        // N·∫øu ƒëang ·ªü room n√†y, hi·ªÉn th·ªã files trong chat
        if (window.chatManager && window.chatManager.currentRoomId == data.roomId) {
            // T·∫°o message gi·∫£ ƒë·ªÉ hi·ªÉn th·ªã files
            const filesMessage = {
                id: 'temp_' + Date.now(),
                content: `üìé ƒê√£ g·ª≠i ${data.files.length} file`, // Content text cho sidebar
                senderId: data.userId,
                senderName: 'B·∫°n',
                createdAt: new Date().toISOString(),
                isRead: true,
                attachments: data.files // S·ª≠ d·ª•ng attachments thay v√¨ files
            };
            
            window.chatManager.addMessageToUI(filesMessage);
        }
        
        // C·∫≠p nh·∫≠t files sidebar n·∫øu ƒëang m·ªü
        if (window.chatFilesManager && window.chatFilesManager.currentRoomId == data.roomId) {
            data.files.forEach(file => {
                window.chatFilesManager.addFile(file);
            });
        }
        
        // Hi·ªÉn th·ªã notification n·∫øu kh√¥ng ph·∫£i files c·ªßa m√¨nh
        const currentUserId = getCurrentUserIdSync();
        if (currentUserId && data.userId !== currentUserId) {
            showFilesNotification(data.files, data.userId);
        }
    }
    
    // Hi·ªÉn th·ªã notification cho tin nh·∫Øn m·ªõi
    function showChatNotification(messageData) {
        if (window.toastManager) {
            const notificationText = `${messageData.senderName}: ${messageData.content}`;
            window.toastManager.info(notificationText);
        }
    }
    
    // Hi·ªÉn th·ªã notification cho file upload
    function showFileNotification(file, userId) {
        if (window.toastManager) {
            const notificationText = `üìé ${file.originalName}`;
            window.toastManager.info(notificationText);
        }
    }
    
    // Hi·ªÉn th·ªã notification cho multiple files upload
    function showFilesNotification(files, userId) {
        if (window.toastManager) {
            const notificationText = `üìé ƒê√£ g·ª≠i ${files.length} file`;
            window.toastManager.info(notificationText);
        }
    }
    
    // Fallback v·ªÅ polling n·∫øu WebSocket kh√¥ng ho·∫°t ƒë·ªông
    function fallbackToPolling() {
        // Polling s·∫Ω ƒë∆∞·ª£c th·ª±c hi·ªán b·ªüi chat-simple.js
        if (window.chatManager) {
            window.chatManager.startPolling();
        }
    }
    
    // L·∫•y current user ID (gi·ªëng nh∆∞ websocket-manager.js)
    async function getCurrentUserId() {
        try {
            // Ki·ªÉm tra cache tr∆∞·ªõc
            if (window.currentUser && window.currentUser.id) {
                return window.currentUser.id;
            }
            
            // G·ªçi API /me ƒë·ªÉ l·∫•y th√¥ng tin user
            const response = await authenticatedFetch('/api/auth/me', {
                method: 'GET',
                credentials: 'include'
            });
            
            if (response.ok) {
                const userData = await response.json();
                if (userData.id) {
                    // L∆∞u v√†o cache ƒë·ªÉ l·∫ßn sau s·ª≠ d·ª•ng
                    window.currentUser = userData;
                    return userData.id;
                }
            }
            
            return null;
        } catch (error) {
            return null;
        }
    }
    
    // L·∫•y current user ID t·ª´ cache (synchronous)
    function getCurrentUserIdSync() {
        return window.currentUser ? window.currentUser.id : null;
    }
    
    // Public API
    window.chatWebSocketManager = {
        // K·∫øt n·ªëi WebSocket
        connect: initializeChatWebSocket,
        
        // Ng·∫Øt k·∫øt n·ªëi
        disconnect: function() {
            if (chatWebSocket) {
                chatWebSocket.close();
                chatWebSocket = null;
            }
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }
        },
        
        // G·ª≠i message
        send: sendChatMessage,
        
        // Ki·ªÉm tra tr·∫°ng th√°i k·∫øt n·ªëi
        isConnected: function() {
            return isConnected && chatWebSocket && chatWebSocket.readyState === WebSocket.OPEN;
        },
        
        // Join room
        joinRoom: function(roomId) {
            sendChatMessage({
                type: 'JOIN_ROOM',
                roomId: roomId
            });
        },
        
        // Leave room
        leaveRoom: function(roomId) {
            sendChatMessage({
                type: 'LEAVE_ROOM',
                roomId: roomId
            });
        },
        
        
        // G·ª≠i message read status
        sendMessageRead: function(roomId) {
            sendChatMessage({
                type: 'MESSAGE_READ',
                roomId: roomId
            });
        },
        
        // L·∫•y current user ID
        getCurrentUserId: getCurrentUserIdSync
    };
    
    // T·ª± ƒë·ªông kh·ªüi t·∫°o khi DOM ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', async () => {
            await initializeChatWebSocket();
        });
    } else {
        initializeChatWebSocket();
    }
    
})();
